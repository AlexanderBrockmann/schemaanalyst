package org.schemaanalyst.util.dbms;

import org.schemaanalyst.configuration.DatabaseConfiguration;
import org.schemaanalyst.configuration.LocationsConfiguration;
import org.schemaanalyst.dbms.DBMS;
import org.schemaanalyst.dbms.DatabaseInteractor;
import org.schemaanalyst.dbms.hypersql.HyperSQLDBMS;
import org.schemaanalyst.sqlrepresentation.Column;
import org.schemaanalyst.sqlrepresentation.Schema;
import org.schemaanalyst.sqlrepresentation.Table;
import org.schemaanalyst.sqlrepresentation.datatype.*;
import org.schemaanalyst.sqlwriter.SQLWriter;
import org.schemaanalyst.testgeneration.TestCaseExecutionException;

import java.text.SimpleDateFormat;
import java.util.*;

/**
 * Created by phil on 21/07/2015.
 */
public class DBMSCompatibleDataTypeResolver {

    private static final String DB_NAME = "compatible_types_testing";

    private List<DataType> dataTypeList;
    private DatabaseInteractor databaseInteractor;
    private SQLWriter sqlWriter;

    public DBMSCompatibleDataTypeResolver() {
        initializeDataTypeList();
    }

    public void writeCompatibleDataTypes(DBMS dbms) {

        databaseInteractor = dbms.getDatabaseInteractor(
                DB_NAME,
                new DatabaseConfiguration(),
                new LocationsConfiguration());

        sqlWriter = dbms.getSQLWriter();

        Map<DataType, Set<DataType>> compatibleTypes = getCompatibleDataTypes();

        outputHeader();
        System.out.println("Map<Class<?>, Set<Class<?>>> types = new HashMap<>();");
        for (DataType sourceType : dataTypeList) {
            Set<DataType> targetTypes = compatibleTypes.get(sourceType);

            if (targetTypes.size() > 0) {
                System.out.println("types.put(" + getClassString(sourceType) + ", new HashSet<Class<?>>());");

                for (DataType targetType : targetTypes) {
                    System.out.println(
                            "types.get(" + getClassString(sourceType) +
                                    ").add(" + getClassString(targetType) + ");");
                }
            }
        }
    }

    private void outputHeader() {
        long currentTime = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("MMM dd,yyyy HH:mm");
        Date resultDate = new Date(currentTime);
        String timeString = sdf.format(resultDate);

        System.out.println("// Generated by " + this.getClass() + " on " + timeString);
    }

    private String getClassString(DataType type) {
        return type.getClass().getSimpleName() + ".class";
    }

    private Map<DataType, Set<DataType>> getCompatibleDataTypes() {
        Map<DataType, Set<DataType>> compatibleDataTypes = new HashMap<>();

        for (DataType type : dataTypeList) {
            compatibleDataTypes.put(type, new HashSet<DataType>());
        }

        for (DataType sourceType : dataTypeList) {
            for (DataType targetType : dataTypeList) {
                boolean result = checkType(sourceType, targetType);

                if (result) {
                    compatibleDataTypes.get(sourceType).add(targetType);
                }
            }
        }

        return compatibleDataTypes;
    }

    private boolean checkType(DataType sourceType, DataType targetType) {
        Schema schema = makeSchema(sourceType, targetType);

        dropTablesIfExist(schema);

        List<String> createStatements = sqlWriter.writeCreateTableStatements(schema);
        if (createStatements.size() != 2) {
            throw new RuntimeException("Exactly two CREATE TABLE statements should have been generated");
        }

        String statement1 = createStatements.get(0);
        Integer result1 = databaseInteractor.executeUpdate(statement1);
        if (result1 < 0) {
            throw new TestCaseExecutionException(
                    "Could not execute CREATE TABLE statement \"" + statement1 +
                            "\" while executing statement 1, result was " + result1);
        }

        String statement2 = createStatements.get(1);
        Integer result2 = databaseInteractor.executeUpdate(statement2);

        boolean result = (result2 >= 0);

        return result;
    }

    private void dropTablesIfExist(Schema schema) {
        List<String> dropTableStatements = sqlWriter.writeDropTableStatements(schema, true);
        for (String statement : dropTableStatements) {
            Integer result = databaseInteractor.executeUpdate(statement);
            if (result < 0) {
                throw new RuntimeException(
                        "Problem while executing DROP TABLE statement \"" + statement + "\", result was " + result);
            }
        }
    }

    private Schema makeSchema(DataType sourceType, DataType targetType) {
        Schema schema = new Schema(DB_NAME);
        Table sourceTable = schema.createTable("source");
        Table targetTable = schema.createTable("target");
        Column sourceColumn = sourceTable.createColumn("sourceColumn", sourceType);
        Column targetColumn = targetTable.createColumn("targetColumn", targetType);
        schema.createPrimaryKeyConstraint(sourceTable, sourceColumn);
        schema.createPrimaryKeyConstraint(targetTable, targetColumn);
        schema.createForeignKeyConstraint(sourceTable, sourceColumn, targetTable, targetColumn);
        return schema;
    }

    private void initializeDataTypeList() {
        dataTypeList = new ArrayList<>();
        dataTypeList.add(new BigIntDataType());
        dataTypeList.add(new BooleanDataType());
        dataTypeList.add(new CharDataType());
        dataTypeList.add(new DateDataType());
        dataTypeList.add(new DateTimeDataType());
        dataTypeList.add(new DecimalDataType());
        dataTypeList.add(new DoubleDataType());
        dataTypeList.add(new FloatDataType());
        dataTypeList.add(new IntDataType());
        dataTypeList.add(new MediumIntDataType());
        dataTypeList.add(new NumericDataType());
        dataTypeList.add(new RealDataType());
        dataTypeList.add(new SingleCharDataType());
        dataTypeList.add(new SmallIntDataType());
        dataTypeList.add(new TextDataType());
        dataTypeList.add(new TimeDataType());
        dataTypeList.add(new TimestampDataType());
        dataTypeList.add(new TinyIntDataType());
        dataTypeList.add(new VarCharDataType());
    }

    public static void main(String[] args) {
        DBMS dbms = new HyperSQLDBMS();
        DBMSCompatibleDataTypeResolver cdt = new DBMSCompatibleDataTypeResolver();
        cdt.writeCompatibleDataTypes(dbms);
    }
}
